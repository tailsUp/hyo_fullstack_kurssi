let gql,ApolloError,yup,uuid,bcrypt,User;_830‍.x([["typeDefs",()=>typeDefs],["resolvers",()=>resolvers],["default",()=>_830‍.o]]);_830‍.w("apollo-server",[["gql",["gql"],function(v){gql=v}],["ApolloError",["ApolloError"],function(v){ApolloError=v}]]);_830‍.w("yup",[["*",null,function(v){yup=v}]]);_830‍.w("uuid",[["v4",["uuid"],function(v){uuid=v}]]);_830‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_830‍.w("../../models/User",[["default",["User"],function(v){User=v}]]);






       const typeDefs = gql`
  input CreateUserInput {
    username: String!
    password: String!
  }

  extend type Mutation {
    """
    Creates a new user, if the provided username does not already exist.
    """
    createUser(user: CreateUserInput): User
  }
`;

class UsernameTakenError extends ApolloError {
  constructor(message, properties) {
    super(message, 'USERNAME_TAKEN', properties);
  }

  static fromUsername(username) {
    return new UsernameTakenError(
      `Username ${username} is already taken. Choose another username`,
      { username },
    );
  }
}

const argsSchema = yup.object().shape({
  user: yup.object().shape({
    username: yup.string().min(1).max(30).lowercase().trim(),
    password: yup.string().min(5).max(50).trim(),
  }),
});

const createPasswordHash = (password) => bcrypt.hash(password, 10);

       const resolvers = {
  Mutation: {
    createUser: async (obj, args) => {
      const {
        user: { password, username, ...user },
      } = await argsSchema.validate(args, {
        stripUnknown: true,
      });

      const passwordHash = await createPasswordHash(password);

      const existingUser = await User.query().findOne({
        username,
      });

      if (existingUser) {
        throw UsernameTakenError.fromUsername(username);
      }

      return User.query().insertAndFetch({
        ...user,
        username,
        password: passwordHash,
        id: uuid(),
      });
    },
  },
};

_830‍.d({
  typeDefs,
  resolvers,
});
