let gql,UserInputError,yup,bcrypt,User;_830‍.x([["typeDefs",()=>typeDefs],["resolvers",()=>resolvers],["default",()=>_830‍.o]]);_830‍.w("apollo-server",[["gql",["gql"],function(v){gql=v}],["UserInputError",["UserInputError"],function(v){UserInputError=v}]]);_830‍.w("yup",[["*",null,function(v){yup=v}]]);_830‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_830‍.w("../../models/User",[["default",["User"],function(v){User=v}]]);





       const typeDefs = gql`
  input AuthenticateInput {
    username: String!
    password: String!
  }

  type AuthenticatePayload {
    user: User!
    accessToken: String!
    expiresAt: DateTime!
  }

  extend type Mutation {
    """
    Generates a new access token, if provided credentials (username and password) match any registered user.
    """
    authenticate(credentials: AuthenticateInput): AuthenticatePayload
  }
`;

const argsSchema = yup.object().shape({
  credentials: yup.object().shape({
    username: yup.string().required().lowercase().trim(),
    password: yup.string().required().trim(),
  }),
});

       const resolvers = {
  Mutation: {
    authenticate: async (obj, args, { authService }) => {
      const {
        credentials: { username, password },
      } = await argsSchema.validate(args, {
        stripUnknown: true,
      });

      const user = await User.query().findOne({ username });

      if (!user) {
        throw new UserInputError('Invalid username or password');
      }

      const match = await bcrypt.compare(password, user.password);

      if (!match) {
        throw new UserInputError('Invalid username or password');
      }

      return {
        user,
        ...authService.createAccessToken(user.id),
      };
    },
  },
};

_830‍.d({
  typeDefs,
  resolvers,
});
